<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="转载自 java正则表达式&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。Java正则表达式和Perl的是最为相似的。


Pattern&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA正则表达式">
<meta property="og:url" content="http://yoursite.com/2015/12/13/javaRegex/index.html">
<meta property="og:site_name" content="WarpTens">
<meta property="og:description" content="转载自 java正则表达式&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。Java正则表达式和Perl的是最为相似的。


Pattern&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要">
<meta property="og:updated_time" content="2016-04-14T01:42:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA正则表达式">
<meta name="twitter:description" content="转载自 java正则表达式&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。Java正则表达式和Perl的是最为相似的。


Pattern&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> JAVA正则表达式 | WarpTens </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">WarpTens</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JAVA正则表达式
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2015-12-13T18:41:06+08:00" content="2015-12-13">
              2015-12-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>转载自 <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="external">java正则表达式</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<br>正则表达式定义了字符串的模式。<br>正则表达式可以用来搜索、编辑或处理文本。<br>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。<br>Java正则表达式和Perl的是最为相似的。</p>
<blockquote>
<ul>
<li><strong>Pattern</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</li>
<li><strong>Matcher</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</li>
<li><strong>PatternSyntaxException</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p> 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。<br>例如，正则表达式(dog) 创建了单一分组，组里包含”d”，”o”，和”g”。<br>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<blockquote>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
</blockquote>
<p>可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多个捕获组。<br>还有一个特殊的组（组0），它总是代表整个表达式。该组不包括在groupCount的返回值中。</p>
<p><strong>下面的例子说明如何从一个给定的字符串中找到数字串：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">      String line = <span class="string">"This order was placed for QT3000! OK?"</span>;</span><br><span class="line">      String pattern = <span class="string">"(.*)(\\d+)(.*)"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">      Pattern r = Pattern.compile(pattern);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">      Matcher m = r.matcher(line);</span><br><span class="line">      <span class="keyword">if</span> (m.find( )) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">0</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">1</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">2</span>) );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"NO MATCH"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上实例编译运行结果如下：</p>
<blockquote>
<p>Found value: This order was placed for QT3000! OK?<br>Found value: This order was placed for QT300<br>Found value: 0</p>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\“匹配”\”，”(“匹配”(“。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次匹配前面的字符或子表达式。例如，zo<em> 匹配”z”和”zoo”。</em> 等效于 {0,}。</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td>?</td>
<td>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (&#124;) 组合模式部件的情况很有用。例如，’industr(?:y&#124;ies) 是比 ‘industry&#124;industries’ 更经济的表达式。</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95&#124;98&#124;NT&#124;2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td>x&#124;y</td>
<td>匹配 x 或 y。例如，’z&#124;food’ 匹配”z”或”food”。’(z&#124;f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td>\B</td>
<td>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td>\cx</td>
<td>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
<td>　</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td>\t</td>
<td>制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td>\W</td>
<td>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td>\xn</td>
<td>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td>\n</td>
<td>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</td>
</tr>
<tr>
<td>\nm</td>
<td>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td>\nml</td>
<td>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</td>
</tr>
<tr>
<td>\un</td>
<td>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody>
</table>
<h2 id="Matcher类的方法"><a href="#Matcher类的方法" class="headerlink" title="Matcher类的方法"></a>Matcher类的方法</h2><h3 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h3><p><strong>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public int start()</td>
<td>返回以前匹配的初始索引。</td>
</tr>
<tr>
<td>public int start(int group)</td>
<td>返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td>
</tr>
<tr>
<td>public int end()</td>
<td>返回最后匹配字符之后的偏移量。</td>
</tr>
<tr>
<td>public int end(int group)</td>
<td>返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td>
</tr>
</tbody>
</table>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p><strong>研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public boolean lookingAt()</td>
<td>尝试将从区域开头开始的输入序列与该模式匹配。</td>
</tr>
<tr>
<td>public boolean find()</td>
<td>尝试查找与该模式匹配的输入序列的下一个子序列。</td>
</tr>
<tr>
<td>public boolean find(int start）</td>
<td>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td>
</tr>
<tr>
<td>public boolean matches()</td>
<td>尝试将整个区域与模式匹配。</td>
</tr>
</tbody>
</table>
<h2 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h2><p><strong>替换方法是替换输入字符串里文本的方法：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Matcher appendReplacement(StringBuffer sb, String replacement)</td>
<td>实现非终端添加和替换步骤。</td>
</tr>
<tr>
<td>public StringBuffer appendTail(StringBuffer sb)</td>
<td>实现终端添加和替换步骤。</td>
</tr>
<tr>
<td>public String replaceAll(String replacement)</td>
<td>替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td>
</tr>
<tr>
<td>public String replaceFirst(String replacement)</td>
<td>替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td>
</tr>
<tr>
<td>public static String quoteReplacement(String s)</td>
<td>返回指定字符串的字面替换字符串。这个方法返回一个字符串，</td>
</tr>
<tr>
<td></td>
<td>就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td>
</tr>
</tbody>
</table>
<h2 id="start-和end-方法"><a href="#start-和end-方法" class="headerlink" title="start 和end 方法"></a>start 和end 方法</h2><p>下面是一个对单词”cat”出现在输入字符串中出现次数进行计数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">"\\bcat\\b"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT =</span><br><span class="line">                                    <span class="string">"cat cat cat cattie cat"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line">       Pattern p = Pattern.compile(REGEX);</span><br><span class="line">       Matcher m = p.matcher(INPUT); <span class="comment">// 获取 matcher 对象</span></span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">         count++;</span><br><span class="line">         System.out.println(<span class="string">"Match number "</span>+count);</span><br><span class="line">         System.out.println(<span class="string">"start(): "</span>+m.start());</span><br><span class="line">         System.out.println(<span class="string">"end(): "</span>+m.end());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下：</p>
<blockquote>
<p>Match number 1<br>start(): 0<br>end(): 3<br>Match number 2<br>start(): 4<br>end(): 7<br>Match number 3<br>start(): 8<br>end(): 11<br>Match number 4<br>start(): 19<br>end(): 22</p>
</blockquote>
<p>可以看到这个例子是使用单词边界，以确保字母 “c” “a” “t” 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。<br>Start方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end方法最后一个匹配字符的索引加1。</p>
<h2 id="matches-和lookingAt-方法"><a href="#matches-和lookingAt-方法" class="headerlink" title="matches 和lookingAt 方法"></a>matches 和lookingAt 方法</h2><p>matches 和lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是matcher要求整个序列都匹配，而lookingAt 不要求。<br>这两个方法经常在输入字符串的开始使用。<br>我们通过下面这个例子，来解释这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">"foo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT = <span class="string">"fooooooooooooooooo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern pattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Matcher matcher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line">       pattern = Pattern.compile(REGEX);</span><br><span class="line">       matcher = pattern.matcher(INPUT);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"Current REGEX is: "</span>+REGEX);</span><br><span class="line">       System.out.println(<span class="string">"Current INPUT is: "</span>+INPUT);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"lookingAt(): "</span>+matcher.lookingAt());</span><br><span class="line">       System.out.println(<span class="string">"matches(): "</span>+matcher.matches());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下：</p>
<blockquote>
<p>Current REGEX is: foo<br>Current INPUT is: fooooooooooooooooo<br>lookingAt(): true<br>matches(): false</p>
</blockquote>
<h2 id="replaceFirst-和replaceAll-方法"><a href="#replaceFirst-和replaceAll-方法" class="headerlink" title="replaceFirst 和replaceAll 方法"></a>replaceFirst 和replaceAll 方法</h2><p>replaceFirst 和replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。<br>下面的例子来解释这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String REGEX = <span class="string">"dog"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String INPUT = <span class="string">"The dog says meow. "</span> +</span><br><span class="line">                                    <span class="string">"All dogs say meow."</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String REPLACE = <span class="string">"cat"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Pattern p = Pattern.compile(REGEX);</span><br><span class="line">       <span class="comment">// get a matcher object</span></span><br><span class="line">       Matcher m = p.matcher(INPUT); </span><br><span class="line">       INPUT = m.replaceAll(REPLACE);</span><br><span class="line">       System.out.println(INPUT);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下：</p>
<blockquote>
<p>The cat says meow. All cats say meow.</p>
</blockquote>
<h2 id="appendReplacement-和-appendTail-方法"><a href="#appendReplacement-和-appendTail-方法" class="headerlink" title="appendReplacement 和 appendTail 方法"></a>appendReplacement 和 appendTail 方法</h2><p>Matcher 类也提供了appendReplacement 和appendTail 方法用于文本替换：<br>看下面的例子来解释这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String REGEX = <span class="string">"a*b"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String INPUT = <span class="string">"aabfooaabfooabfoob"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String REPLACE = <span class="string">"-"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Pattern p = Pattern.compile(REGEX);</span><br><span class="line">      <span class="comment">// 获取 matcher 对象</span></span><br><span class="line">      Matcher m = p.matcher(INPUT);</span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">         m.appendReplacement(sb,REPLACE);</span><br><span class="line">      &#125;</span><br><span class="line">      m.appendTail(sb);</span><br><span class="line">      System.out.println(sb.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下：</p>
<blockquote>
<p>-foo-foo-foo-</p>
</blockquote>
<h2 id="PatternSyntaxException-类的方法"><a href="#PatternSyntaxException-类的方法" class="headerlink" title="PatternSyntaxException 类的方法"></a>PatternSyntaxException 类的方法</h2><p>PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。<br>PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String getDescription()</td>
<td>获取错误的描述。</td>
</tr>
<tr>
<td>public int getIndex()</td>
<td>获取错误的索引。</td>
</tr>
<tr>
<td>public String getPattern()</td>
<td>获取错误的正则表达式模式。</td>
</tr>
<tr>
<td>public String getMessage()</td>
<td>返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视指示。</td>
</tr>
</tbody>
</table>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag">#java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/12/javaMultiThread/" rel="next" title="java多线程总结">
                <i class="fa fa-chevron-left"></i> java多线程总结
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/19/lanqiao2015/" rel="prev" title="转-蓝桥杯2015省赛c/c++　Ｂ组">
                转-蓝桥杯2015省赛c/c++　Ｂ组 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="WarpTens" />
          <p class="site-author-name" itemprop="name">WarpTens</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获组"><span class="nav-number">1.</span> <span class="nav-text">捕获组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Matcher类的方法"><span class="nav-number">2.</span> <span class="nav-text">Matcher类的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引方法"><span class="nav-number">2.1.</span> <span class="nav-text">索引方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#研究方法"><span class="nav-number">3.</span> <span class="nav-text">研究方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#替换方法"><span class="nav-number">4.</span> <span class="nav-text">替换方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-和end-方法"><span class="nav-number">5.</span> <span class="nav-text">start 和end 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#matches-和lookingAt-方法"><span class="nav-number">6.</span> <span class="nav-text">matches 和lookingAt 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#replaceFirst-和replaceAll-方法"><span class="nav-number">7.</span> <span class="nav-text">replaceFirst 和replaceAll 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#appendReplacement-和-appendTail-方法"><span class="nav-number">8.</span> <span class="nav-text">appendReplacement 和 appendTail 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PatternSyntaxException-类的方法"><span class="nav-number">9.</span> <span class="nav-text">PatternSyntaxException 类的方法</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WarpTens</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
